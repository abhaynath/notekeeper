<!--
  https://kotlinlang.org/docs/constructing-collections.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" type="text/css" href="../../css/style.css" />
    <link
      rel="stylesheet"
      href="../../css/font-awesome-4.7.0/css/font-awesome.min.css"
    />

    <link
      rel="stylesheet"
      href="../../js/libs/highlight/styles/devibeans.min.css"
    />
    <script src="../../js/libs/highlight/highlight.min.js"></script>
    <script src="../../js/libs/jquery.min.js"></script>
    <title>Collections</title>
  </head>

  <body>
    <nav class="nav_main">
      <a href="../../index.html"><i class="fa fa-home"></i></a>
      <a href="kotlin_index.html">Kotlin</a>
    </nav>
    <div class="content">
      <section id="construct">
        <h4>Construct from elements</h4>
        <p>
          The most common way to create a collection is with the standard
          library functions listOf&#x3C;T&#x3E;(), setOf&#x3C;T&#x3E;(),
          mutableListOf&#x3C;T&#x3E;(), mutableSetOf&#x3C;T&#x3E;(). If you
          provide a comma-separated list of collection elements as arguments,
          the compiler detects the element type automatically. When creating
          empty collections, specify the type explicitly.
        </p>
        <pre> <code class="language-kt">
val numbersSet = setOf(&#x22;one&#x22;, &#x22;two&#x22;, &#x22;three&#x22;, &#x22;four&#x22;)
val emptySet = mutableSetOf&#x3C;String&#x3E;()</code></pre>
        <p>
          The same is available for maps with the functions mapOf() and
          mutableMapOf(). The map&#x27;s keys and values are passed as Pair
          objects (usually created with to infix function).
        </p>
        <pre> <code class="language-kt">
val numbersMap = mutableMapOf<String, String>().apply { this["one"] = "1"; this["two"] = "2" }</code></pre>
        <p>
          Note that the to notation creates a short-living Pair object, so
          it&#x27;s recommended that you use it only if performance isn&#x27;t
          critical. To avoid excessive memory usage, use alternative ways. For
          example, you can create a mutable map and populate it using the write
          operations. The apply() function can help to keep the initialization
          fluent here.
        </p>
        <pre><code class="language-kt">val numbersMap = mutableMapOf&#x3C;String, String&#x3E;().apply { this[&#x22;one&#x22;] = &#x22;1&#x22;; this[&#x22;two&#x22;] = &#x22;2&#x22; }
        </code></pre>
      </section>

      <section id="builder">
        <h4>Create with collection builder functions</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="empty">
        <h4>Empty collections</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="list">
        <h4>Initializer functions for lists</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="concrete">
        <h4>Concrete type constructors</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="copy">
        <h4>Copy</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="invoke">
        <h4>Invoke functions on other collections</h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>

      <section id="">
        <h4></h4>
        <pre> <code class="language-kt">
        </code></pre>
      </section>
    </div>
  </body>

  <script>
    hljs.highlightAll();
  </script>
</html>
